<#@ template language="C#" linePragmas="false" visibility="internal" inherits="SimpleGeneratorBase" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="Microsoft.CodeAnalysis" #>
<#
    var infoVer =
        typeof(GeneratorBase).Assembly.GetCustomAttribute<AssemblyInformationalVersionAttribute>()?.InformationalVersion;
#>
/*
<auto-generated>
This file was generated by ComparisonGenerator (https://github.com/aetos382/ComparisonGenerator).
DO NOT EDIT THIS FILE MANUALLY.
<#
    if (!string.IsNullOrEmpty(infoVer))
    {
#>

Generator version: <#= infoVer #>.
<#
    }
#>
</auto-generated>
*/

<#
    var nullableContext = this.SourceTypeInfo.NullableContext;

    bool annotationsEnabled = nullableContext.AnnotationsEnabled();
    bool warningsEnabled = nullableContext.WarningsEnabled();

    var pragmaValue = (annotationsEnabled, warningsEnabled) switch {
        (true, true) => "enable",
        (true, false) => "enable annotations",
        (false, true) => "enable warnings",
        _ => null
    };

    if (pragmaValue is not null)
    {
#>
#nullable <#= pragmaValue #>
<#
    }
#>

using System;
<#
this.WriteUsings();
#>

<#
var sourceTypeInfo = this.SourceTypeInfo;

var namespaceName = sourceTypeInfo.NamespaceName;
bool hasNamespace = !string.IsNullOrEmpty(namespaceName);
if (hasNamespace)
{
#>
namespace <#= namespaceName #>
{
<#
    this.PushIndent();
}

var enclosingTypes = sourceTypeInfo.EnclosingTypes;
int numEnclosingTypes = enclosingTypes.Count;

for (int i = 0; i < numEnclosingTypes; ++i)
{
    var type = enclosingTypes[i];
    string typeKind = GetTypeKind(type);
#>
partial <#= typeKind #> <#= type.Name #>
{
<#
    this.PushIndent();
}

this.WriteCode();

for (int i = 0; i < numEnclosingTypes; ++i)
{
    this.PopIndent();
#>
}
<#
}
#>
<#
// end namespace
if (hasNamespace)
{
    this.PopIndent();
#>
}
<#
}
#>
